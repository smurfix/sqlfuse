#!/usr/bin/python -tt
# -*- coding: utf-8 -*-

#    Copyright (C) 2010  Matthias Urlichs <matthias@urlichs.de>
#
#    This program may be distributed under the terms of the GNU GPLv3.
#
## This file is formatted with tabs.
## Do NOT introduce leading spaces.

from __future__ import division, print_function, absolute_import

import errno, fcntl, os, stat, sys, traceback
from smurf import Db,Cf

import llfuse
from llfuse import FUSEError
import inspect
import traceback
from threading import Lock,Thread,Condition
from time import sleep

import datetime
utcnow = datetime.datetime.utcnow

# map fdnum â‡’ filehandle
_slot = {}
_slot_next = 1
def new_slot(x):
	global _slot_next
	_slot_next += 1
	while _slot_next in _slot:
		if _slot_next == 999999999:
			_slot_next = 1
		else:
			_slot_next += 1
	_slot[_slot_next] = x
	return _slot_next
def old_slot(x):
	return _slot[x]
def del_slot(x):
	res = _slot[x]
	del _slot[x]
	return res

# busy-inode flag
_busy = {}
def set_busy(i):
	if i in _busy:
		_busy[i] += 1
	else:
		_busy[i] = 1
def is_busy(i):
	return (i in _busy)
def clr_busy(i):
	#return True if it's to be deleted
	b = _busy[i]
	if b < 0:
		b += 1
		if b == 0:
			del _busy[i]
			return True
	else:
		b -= 1
		if b == 0:
			del _busy[i]
	return False
def defer_delete(i):
	if i not in _busy:
		return False
	if _busy[i] > 0:
		_busy[i] = -_busy[i]
	return True
def no_defer_delete(i):
	if i not in _busy:
		return
	if _busy[i] < 0:
		_busy[i] = -_busy[i]

def log_call():
	c=inspect.currentframe(1)
	print(">>>",c.f_code.co_name,"@",c.f_lineno,repr(c.f_locals))
	
def flag2mode(flags):
	if flags & os.O_APPEND:
		mode = "a"
	else:
		mode = "w"
	f = (flags & (os.O_WRONLY|os.O_RDONLY|os.O_RDWR))
	if f == os.O_RDONLY:
		mode = "r"
	elif f == os.O_RDWR:
		mode += "+"

	return mode

class BackgroundUpdater(Thread):
	def __init__(self,tree):
		super(BackgroundUpdater,self).__init__()
		self.tree = tree
		self.lock = Condition()
		self.state = False

	def run(self):
		while True:
			#print("T1")
			self.lock.acquire()
			#print("T2")
			while self.state is False:
				#print("T4")
				self.lock.wait()
			if self.state is None:
				#print("T5")
				self.lock.release()
				return
			#print("T6")
			self.state = False
			self.lock.release()

			vals = _slot.values()
			for val in vals:
				#print("T7",val)
				if val.mtime is not None:
					val.update_bg()
			#print("T8")
			sleep(0.5)
				

class FileOperations(object):
	mtime = None
	def __init__(self, tree, inode, flags):
		log_call()
		self.tree = tree
		self.inode = inode
		self.lock = Lock()
		mode = flag2mode(flags)
		self.mode = mode[0]
		self.size, = tree.db.DoFn("select size from inode where id=${inode}",inode=inode)
		self.file = open(os.path.join(tree.store,str(inode)),mode)

	def update_bg(self):
		mt = self.mtime
		self.mtime = None
		try:
			self.tree.db.Do("update inode set mtime=${mtime},size=${size} where id=${inode}", inode=self.inode, mtime=mt.strftime("%s"), size=self.size )
		except Db.NoData:
			pass # one-second interval
		self.tree.db.commit()

	def read(self, length,offset):
		log_call()
		with self.lock:
			self.file.seek(offset)
			return self.file.read(length)

	def write(self, buf,offset):
		log_call()
		with self.lock:
			self.file.seek(offset)
			self.file.write(buf)
			
			end = offset+len(buf)
			if self.size < end:
				self.size = end
			self.mtime = utcnow()
			self.tree.trigger_bg()
			return len(buf)

	def release(self):
		log_call()
		if self.mtime is not None:
			self.update_bg()
		self.file.close()

	def _fflush(self):
		log_call()
		self.file.flush()

	def fsync(self, data_only):
		log_call()
		if data_only and hasattr(os, 'fdatasync'):
			os.fdatasync(self.file.fileno())
		else:
			os.fsync(self.file.fileno())
			self.update_bg()

	def flush(self):
		log_call()
		self._fflush()

	def fgetattr(self):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		return os.fstat(self.fd)

	def ftruncate(self, len):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		self.file.truncate(len)

	def lock(self, cmd, owner, **kw):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		# The code here is much rather just a demonstration of the locking
		# API than something which actually was seen to be useful.

		# Advisory file locking is pretty messy in Unix, and the Python
		# interface to this doesn't make it better.
		# We can't do fcntl(2)/F_GETLK from Python in a platfrom independent
		# way. The following implementation *might* work under Linux. 
		#
		# if cmd == fcntl.F_GETLK:
		#     import struct
		# 
		#     lockdata = struct.pack('hhQQi', kw['l_type'], os.SEEK_SET,
		#                            kw['l_start'], kw['l_len'], kw['l_pid'])
		#     ld2 = fcntl.fcntl(self.fd, fcntl.F_GETLK, lockdata)
		#     flockfields = ('l_type', 'l_whence', 'l_start', 'l_len', 'l_pid')
		#     uld2 = struct.unpack('hhQQi', ld2)
		#     res = {}
		#     for i in xrange(len(uld2)):
		#          res[flockfields[i]] = uld2[i]
		#  
		#     return fuse.Flock(**res)

		# Convert fcntl-ish lock parameters to Python's weird
		# lockf(3)/flock(2) medley locking API...
		op = { fcntl.F_UNLCK : fcntl.LOCK_UN,
			   fcntl.F_RDLCK : fcntl.LOCK_SH,
			   fcntl.F_WRLCK : fcntl.LOCK_EX }[kw['l_type']]
		if cmd == fcntl.F_GETLK:
			raise FUSEError(errno.EOPNOTSUPP)
		elif cmd == fcntl.F_SETLK:
			if op != fcntl.LOCK_UN:
				op |= fcntl.LOCK_NB
		elif cmd == fcntl.F_SETLKW:
			pass
		else:
			raise FUSEError(errno.EINVAL)

		fcntl.lockf(self.fd, op, kw['l_start'], kw['l_len'])

class DirOperations(object):
	mtime = None
	def __init__(self, tree, inode):
		log_call()
		self.inode = inode
		self.tree = tree

	def read(self, offset):
		# We use the actual inode as offset
		log_call()
		if offset == 0:
			yield (".", self.tree.getattr(self.inode), 0)
			offset = 1
		if offset == 1:
			par, = self.tree.db.DoFn("select parent from tree where inode=${inode}", inode=self.inode)
			yield ("..", self.tree.getattr(self.inode), 0)
			offset = 2

		for n,i in self.tree.db.DoSelect("select name,inode from tree where parent=${par} and name != '' and inode > ${offset}", par=self.inode,offset=offset-2, _empty=True,_store=True):
			yield (n, self.tree.getattr(i), i+2)

	def release(self):
		log_call()
		return

	def fsync(self):
		log_call()
		return


class SqlFuse(llfuse.Operations):
	node = Cf.get("SQL_NODE","default")
	user = Cf.get("SQL_USER",os.environ['USER'])
	password = Cf.get("SQL_PASS","")
	host=Cf.get("SQL_HOST","localhost")
	port=int(Cf.get("SQL_PORT",3306))
	database=Cf.get("SQL_DB","sqlfuse")
	dbtype=Cf.get("SQL_DBTYPE","mysql")

	def _file_path(self, inode):
		return os.path.join(self.store, str(inode))

#	def _inode_path(self, path, tail=0):
#		if path[0] != '/':
#			raise FUSEError(errno.ENOENT)
#		path = path.split('/')
#		while path:
#			name = path.pop()
#			if name != '':
#				break
#		if not tail:
#			path.append(name)
#		depth=0
#		q=[""]
#		qa = {"root":self.inode}
#		for p in path:
#			if p == '':
#				continue
#			depth += 1
#			q.append("JOIN tree AS t%d ON t%d.inode = t%d.parent and t%d.name=${t%d_name}" % (depth, depth-1, depth, depth, depth))
#			qa["t"+str(depth)+"_name"] = p
#		q[0]="SELECT t%d.inode from tree as t0" % (depth,)
#		q.append("where t0.inode=${root}")
#		ino, = self.db.DoFn(" ".join(q),**qa)
#		return ino,name

	def _lookup(self, inode_p, name):
		if name == '.':
			inode = inode_p
		elif name == '..':
			inode, = self.db.DoFn("select parent from tree where inode=${inode}",inode=inode_p)
		else:
			try:
				inode, = self.db.DoFn("select inode from tree where parent=${inode} and name=${name}", inode=inode_p, name=name)
			except Db.NoData:
				raise(llfuse.FUSEError(errno.ENOENT))
		return inode
	    
	def lookup(self, inode_p, name):
		return self.getattr(self._lookup(inode_p,name))

	def handle_exc(self,fn,exc):
		log_call()
		traceback.print_exc()

	def getattr(self, inode):
		log_call()
		res = llfuse.EntryAttributes()
		res.st_ino = inode
		res.st_nlink, = self.db.DoFn("select count(*) from tree where inode=${inode}",inode=inode)
		d = self.db.DoFn("select * from inode where id=${inode}", inode=inode, _dict=1)
		for k,v in d.iteritems():
			setattr(res,"st_"+k,v)
		if stat.S_ISDIR(res.st_mode): 
			res.st_nlink += 2
		res.st_blocks = ((d['size']+4095)//4096)
		res.st_blksize = 4096
		res.st_dev=0
		res.st_rdev=0
		res.generation = 1;
		res.attr_timeout = 10;
		res.entry_timeout = 10;
		print(repr(res.__dict__))
		self.db.commit()
		return res

	def setattr(self, inode, attr):
		log_call()
		a=[]
		b={}
		print(repr(attr.__dict__))
		if attr.st_size is not None:
			with file(self._file_path(inode),"r+") as f:
				f.truncate(attr.st_size)
		for f in ("size uid gid atime mtime".split()):
			v = getattr(attr,"st_"+f)
			if v is not None:
				a.append(f)
				b[f]=v
		if a:
			a.append("ctime")
			b["ctime"] = utcnow().strftime("%s")

			self.db.Do("update inode set "+(", ".join(("%s=${%s}"%(x,x) for x in a)))+" where id=${inode}", inode=inode,**b)
		return self.getattr(inode)

	def readlink(self, inode):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def opendir(self, inode):
		return new_slot(DirOperations(tree=self, inode=inode))

	def readdir(self, fh, offset):
		log_call()
		return old_slot(fh).read(offset)
		
	def fsyncdir(self, fh):
		log_call()
		return old_slot(fh).fsync()

	def releasedir(self, fh):
		log_call()
		return del_slot(fh).release()

	def unlink(self, inode_p, name):
		log_call()
		inode = self._lookup(inode_p,name)
		mode, = self.db.DoFn("select mode from inode where id=${inode}", inode=inode)
		if stat.S_ISDIR(mode):
			raise FUSEError(errno.EISDIR)
		if not defer_delete(inode):
			self._remove(inode)
		else:
			self.db.commit()

	def rmdir(self, path):
		log_call()
		inode = self._lookup(inode_p,name)
		mode, = self.db.DoFn("select mode from inode where id=${inode}", inode=inode)
		if not stat.S_ISDIR(mode):
			raise FUSEError(errno.ENOTDIR)
		cnt, = self.db.DoFn("select count(*) from tree where parent=${inode}")
		if cnt:
			raise FUSEError(errno.ENOTEMPTY)
		self._remove(inode)

	def _remove(self,inode):
		log_call()
		try:
			os.unlink(self._file_path(inode))
		except OSError as e:
			if e.errno != errno.ENOENT:
				raise
		self.db.Do("delete from tree where inode=${inode}", inode=inode)
		self.db.Do("delete from inode where id=${inode}", inode=inode)
		self.db.commit()

	def symlink(self, path, path1):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def rename(self, path, path1):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def link(self, path, path1):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def chmod(self, path, mode):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def chown(self, path, user, group):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def truncate(self, path, len):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		#f = open("." + path, "a")
		#f.truncate(len)
		#f.close()

	def mknod(self, parent, name, mode, rdev, ctx):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def mkdir(self, parent, name, mode, rdev, ctx):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def utime(self, path, times):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

#    The following utimens method would do the same as the above utime method.
#    We can't make it better though as the Python stdlib doesn't know of
#    subsecond preciseness in acces/modify times.
#  
	def utimens(self, path, ts_acc, ts_mod):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

	def bmap(self, *a,**k):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)

## not called because default_permissions is set
#	def access(self, inode, mode, ctx):
#		log_call()
#		raise FUSEError(errno.EOPNOTSUPP)

#    This is how we could add stub extended attribute handlers...
#    (We can't have ones which aptly delegate requests to the underlying fs
#    because Python lacks a standard xattr interface.)
#
	def getxattr(self, inode, name):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		val = name.swapcase() + '@' + path
		if size == 0:
			# We are asked for size of the value.
			return len(val)
		return val

	def setxattr(self, inode, name, value):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		# TODO
		return

	def listxattr(self, inode):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		# We use the "user" namespace to please XFS utils
		aa = ["user." + a for a in ("foo", "bar")]
		if size == 0:
			# We are asked for size of the attr list, ie. joint size of attrs
			# plus null separators.
			return len("".join(aa)) + len(aa)
		return aa

	def removexattr(self, inode, name):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		# TODO
		return

	def statfs(self):
		"""
		Should return an object with statvfs attributes (f_bsize, f_frsize...).
		Eg., the return value of os.statvfs() is such a thing (since py 2.2).
		If you are not reusing an existing statvfs object, start with
		fuse.StatVFS(), and define the attributes.

		To provide usable information (ie., you want sensible df(1)
		output, you are suggested to specify the following attributes:

			- f_bsize - preferred size of file blocks, in bytes
			- f_frsize - fundamental size of file blcoks, in bytes
				[if you have no idea, use the same as blocksize]
			- f_blocks - total number of blocks in the filesystem
			- f_bfree - number of free blocks
			- f_files - total number of file inodes
			- f_ffree - nunber of free file inodes
		"""
		log_call()

		return os.statvfs(".")

	def open(self, inode,flags):
		log_call()
		res = FileOperations(tree=self, inode=inode, flags=flags)
		self.db.commit()
		return new_slot(res)

	def create(self, par,name,mode,ctx):
		log_call()
		ino = None
		try:
			ino, = self.db.DoFn("select inode from tree where parent=${par} and name=${name}", par=par,name=name)
		except Db.NoData:
			ino = self.db.Do("insert into inode (mode,uid,gid,atime,mtime,ctime) values(${mode},${uid},${gid},${now},${now},${now})", mode=mode|stat.S_IFREG, uid=ctx.uid,gid=ctx.gid, now=utcnow().strftime("%s"))
			self.db.Do("insert into tree (inode,parent,name) values(${ino},${par},${name})", ino=ino,par=par,name=name)
		else:
			if flags & os.O_EXCL:
				self.db.commit()
				raise FUSEError(errno.EEXIST)

		res = FileOperations(tree=self, inode=ino, flags=os.O_RDWR|os.O_CREAT)
		return (new_slot(res),self.getattr(ino))

	def read(self, fh,off,size):
		log_call()
		res = old_slot(fh).read(size,off)
		log_call()
		return res

	def write(self, fh,off,buf):
		log_call()
		res = old_slot(fh).write(buf,off)
		log_call()
		return res

	def release(self, fh):
		log_call()
		return del_slot(fh).release()

	def _fflush(self):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		if 'w' in self.file.mode or 'a' in self.file.mode:
			self.file.flush()

	def fsync(self, fh,data_only): #isfsyncfile):
		log_call()
		return old_slot(fh).fsync(data_only)

	def flush(self, fh):
		log_call()
		old_slot(fh).flush()

	def fgetattr(self, *a,**k):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		return os.fstat(self.fd)

	def ftruncate(self, *a,**k):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		self.file.truncate(len)

	def lock(self, *a,**k): #cmd, owner):
		log_call()
		raise FUSEError(errno.EOPNOTSUPP)
		# The code here is much rather just a demonstration of the locking
		# API than something which actually was seen to be useful.

		# Advisory file locking is pretty messy in Unix, and the Python
		# interface to this doesn't make it better.
		# We can't do fcntl(2)/F_GETLK from Python in a platfrom independent
		# way. The following implementation *might* work under Linux. 
		#
		# if cmd == fcntl.F_GETLK:
		#     import struct
		# 
		#     lockdata = struct.pack('hhQQi', kw['l_type'], os.SEEK_SET,
		#                            kw['l_start'], kw['l_len'], kw['l_pid'])
		#     ld2 = fcntl.fcntl(self.fd, fcntl.F_GETLK, lockdata)
		#     flockfields = ('l_type', 'l_whence', 'l_start', 'l_len', 'l_pid')
		#     uld2 = struct.unpack('hhQQi', ld2)
		#     res = {}
		#     for i in xrange(len(uld2)):
		#          res[flockfields[i]] = uld2[i]
		#  
		#     return fuse.Flock(**res)

		# Convert fcntl-ish lock parameters to Python's weird
		# lockf(3)/flock(2) medley locking API...
		op = { fcntl.F_UNLCK : fcntl.LOCK_UN,
			   fcntl.F_RDLCK : fcntl.LOCK_SH,
			   fcntl.F_WRLCK : fcntl.LOCK_EX }[kw['l_type']]
		if cmd == fcntl.F_GETLK:
			raise FUSEError(errno.EOPNOTSUPP)
		elif cmd == fcntl.F_SETLK:
			if op != fcntl.LOCK_UN:
				op |= fcntl.LOCK_NB
		elif cmd == fcntl.F_SETLKW:
			pass
		else:
			raise FUSEError(errno.EINVAL)

		fcntl.lockf(self.fd, op, kw['l_start'], kw['l_len'])

	def init_db(self,db,node):
		log_call()
		# TODO: setup a copying thread
		self.db = db
		try:
			self.node_id,self.inode,self.store = self.db.DoFn("select id,inode,files from node where name=${name}", name=self.node)
		except Db.NoData:
			raise RuntimeError("data for '%s' is missing"%(self.node,))
		try:
			mode,=db.DoFn("select mode from inode where id=${inode}",inode=self.inode)
		except Db.NoData:
			raise RuntimeError("database has not been initialized: inode %d is missing" % (self.inode,))
		if mode == 0:
			db.Do("update inode set mode=${dir} where id=${inode}", dir=stat.S_IFDIR|stat.S_IRWXU|stat.S_IRWXG|stat.S_IRWXO, inode=self.inode)
		db.commit()

	def trigger_bg(self, s=True):
		#print("R1")
		self.dbt.lock.acquire()
		#print("R2")
		if self.dbt.state is False or s is None:
			#print("R3")
			self.dbt.state = s
			self.dbt.lock.notify()
		#print("R4")
		self.dbt.lock.release()
		#print("R5")

	def init(self):
		log_call()
		self.dbt = BackgroundUpdater(self)
		self.dbt.start()

	def destroy(self):
		log_call()
		self.trigger_bg(None) # shutdown updater thread
		self.dbt.join()
		pass

def opts(server,p=None,usage=None):
	from fuseparts.subbedopts import SubbedOptParse
	if p is False:
		def opt(name,**k):
			p.add_option('-o', subopt=name, **k)
		def rv():
			return p.print_help()
		p = SubbedOptParse(usage=usage)
	elif p is None:
		def opt(name,**k):
			p.add_option('-o', subopt=name, **k)
		def rv():
			return p.parse_args(sys.argv[2:])
		p = SubbedOptParse(usage=usage)
	else:
		from optparse import OptionParser
		p = OptionParser(usage=usage)
		def opt(name,**k):
			p.add_option('--'+name, **k)
		def rv():
			return p.parse_args(sys.argv[1:])

	opt("node", dest="node", default="node",
		help="file storage node name [default: %default]")
	opt("user", dest="username", default=server.user,
		help="SQL user name [default: %default]")
	opt("password", dest="password", default=server.password,
		help="SQL password [default: %default]")
	opt("host", dest="host", default=server.host,
		help="SQL database host [default: %default]")
	opt("port", dest="port", default=server.port, type="int",
		help="SQL database name [default: %default]")
	opt("database", dest="database", default=server.database,
		help="SQL database name [default: %default]")
	opt("dbtype", dest="dbtype", default=server.dbtype,
		help="SQL database type [default: %default]")

	return rv()

def main():
	if len(sys.argv) < 2 or sys.argv[1] == "help":
		usage = """
sqlmount /mountpoint [options ...]
	Mount an SQL-based file system.
sqlmount --help
	Print usage information for mounting.

sqlmount help
	Print usage information for non-mounting modes.

*sqlmount info [--node=NAME] [path...]
	List generic information for this SQL node.
	If paths are specified, list the detailed state for that file/dir.

*sqlmount list nodes
	List which nodes are known.
*sqlmount list node NAME
	List details from the named node.
*sqlmount add node NAME path STORAGE
	Create a new directory hierarchy for storing in STORAGE.
*sqlmount change node NAME [new NAME] [path STORAGE]
	Change this directory hierarchy for storing in STORAGE.
	You need to copy files from the old to the new storage
	before running this command!
*sqlmount clone node NAME new NAME path STORAGE
	Create a copy of an existing directory hierarchy.
	You'll also need to specify where to copy files from; see below.
*sqlmount del node NAME
	Delete this node.

*sqlmount list copy
	List all copying commands.
*sqlmount list copy A B
	List details of the copy command which copies stuff from node A to B.
*sqlmount add copy A B prio N mode HOW via CMD [ondemand|background]
*sqlmount change copy A B [prio N] [mode HOW [via CMD]] [ondemand|background]
	Add or change a command to copy stuff from A to B.
	If 'ondemand' is specified, this is a caching method.
	Otherwise, copying of all files will run in the background.
*sqlmount del copy A B
	Delete this method to copy files.

* These commands are not implemented yet.
"""
		p=opts(SqlFuse,False,usage)
		sys.exit(0)
	else:
		usage = """
sqlmount /path -o option...: mount a file hierarchy from a SQL database.

sqlmount help  -- list other modes and options
""" 

		server = SqlFuse()
		opt,arg = opts(server, usage=usage)

		db = Db.Db(dbtye=opt.dbtype,host=opt.host,port=opt.port,database=opt.database,username=opt.username,password=opt.password)
		server.init_db(db, opt.node)
	
		llfuse.init(server, sys.argv[1], 
			[  b'fsname=SqlFuse', b'nonempty', b'max_read=1048576', b'default_permissions', b'allow_root' ])
		try:
			llfuse.main()
		finally:
			llfuse.close()
		

if __name__ == '__main__':
	main()
