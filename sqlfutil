#!/usr/bin/python -tt
# -*- coding: utf-8 -*-

#    Copyright (C) 2010  Matthias Urlichs <matthias@urlichs.de>
#
#    This program may be distributed under the terms of the GNU GPLv3.
#
## This file is formatted with tabs.
## Do NOT introduce leading spaces.

from __future__ import division, print_function, absolute_import

from sqlmix import Db,NoData

#from sqlfuse import SqlFuse
from sqlfuse.options import options
from sqlfuse.range import Range
from datetime import datetime,timedelta
import sys

typ = {
	"n":"new",
	"c":"write",
	"f":"finish",
	"d":"delete",
	"i":"init",
	}
def report(seq):
	for k in seq:
		print(" ".join((unicode(x) for x in k)))
	print("")

def format_time(s,ns):
	if not s:
		v = "epoch"
	else:
		v = datetime.utcfromtimestamp(s)
		if ns:
			v += timedelta(0,0,ns//1000)
			v = v.strftime("%F %T.%f")
		else:
			v = v.strftime("%F %T")
	return v

def node_info(db,node_id):
	yield ("node","ID",node_id)
	d = db.DoFn("select * from node where id=${id}",id=node_id, _dict=1)
	for f in "root name files".split():
		yield (f,d[f])
	for ch,ta,tb,t in db.DoSelect("select count(*),min(id),max(id),typ from event where node=${node} group by typ", node=node_id, _empty=True):
		yield ("nchanges",typ[t],ch)
		yield ("change","first",ta)
		yield ("change","last",tb)

def root_info(db,root_id):
	yield ("root","ID",root_id)
	d = db.DoFn("select * from root where id=${id}",id=root_id, _dict=1)
	for f in "name inode nfiles ndirs nblocks".split():
		yield (f,d[f])
	n, = db.DoFn("select count(*) from node where root=${root}",root=root_id)
	yield ("nnodes",n)

def inode_info(db,inum):
	yield ("inode","ID",inum)
	d = db.DoFn("select * from inode where id=${id}",id=inum, _dict=1)
	for f in "uid gid mtime atime ctime size event copies seq".split():
		v = d[f]
		if f.endswith("time"):
			v = format_time(v,d[f+"_ns"])
		yield (f,v)
	n, = db.DoFn("select count(*) from tree where inode=${inode}",inode=inum)
	yield ("nlinks",n)
	for k,v in db.DoSelect("select xattr_name.name, xattr.value from xattr,xattr_name where xattr.inode=${inode} and xattr.name=xattr_name.id", inode=inum, _empty=1):
		yield ("attr",k,repr(v))
	
	try:
		def get_path(inum,prev=""):
			try:
				inum_p,name = db.DoFn("select parent,name from tree where inode=${inode}",inode=inum)
			except NoData:
				return prev,inum
			else:
				return get_path(inum_p,name+"/"+prev)


		for p,n in db.DoSelect("select parent,name from tree where inode=${inode}",inode=inum):
			path,root_inum = get_path(p,n)
			root,=db.DoFn("select name from root where inode=${root}",root=root_inum)
			yield("path",root,repr(path.encode("utf-8")))
	except NoData:
		root,=db.DoFn("select name from root where inode=${root}",root=inum)
		yield("path",root,"/")
	for i,n in db.DoSelect("select inode,name from tree where parent=${inode}", inode=inum, _empty=1):
		yield("entry",i,repr(n.encode("utf-8")))

	for i,n in db.DoSelect("select parent,name from tree where inode=${inode}", inode=inum, _empty=1):
		yield("parent",i,repr(n.encode("utf-8")))

def event_info(db,event_id):
	yield ("event","ID",event_id)
	d = db.DoFn("select * from event where id=${id}",id=event_id, _dict=1)
	yield("typ",typ[d["typ"]])
	for f in "inode node".split():
		yield(f,d[f])
	r = d["range"]
	if r:
		r = Range(r)
		yield("range",str(r))

	try: nid, = db.DoFn("select max(id) from event where inode=${inode} and id<${id}", inode=d["inode"],id=event_id)
	except NoData: pass
	else:
		if nid: yield ("prev","inode","event",nid)

	try: nid, = db.DoFn("select min(id) from event where inode=${inode} and id>${id}", inode=d["inode"],id=event_id)
	except NoData: pass
	else:
		if nid: yield ("next","inode","event",nid)

	try: nid, = db.DoFn("select max(id) from event where node=${node} and id<${id}", node=d["node"],id=event_id)
	except NoData: pass
	else:
		if nid: yield ("prev","node","event",nid)

	try: nid, = db.DoFn("select min(id) from event where node=${node} and id>${id}", node=d["node"],id=event_id)
	except NoData: pass
	else:
		if nid: yield ("next","node","event",nid)


def main():
	"""Main program."""
	
#*sqlmount info [--node=NAME] [path...]
#	List generic information for this SQL node.
#	If paths are specified, list the detailed state for that file/dir.
#
#*sqlmount list root
#	List which roots are known.
#*sqlmount list root NAME
#	List details from the named root.
#*sqlmount add root NAME path SUBDIR
#	Create a new directory hierarchy.
#*sqlmount change root NAME [new NAME]
#	Change this directory hierarchy.
#*sqlmount del root NAME
#	Delete this root.
#
#*sqlmount list nodes
#	List which nodes are known.
#*sqlmount list node NAME
#	List details from the named node.
#*sqlmount add node NAME root NAME path STORAGE
#	Create a new directory hierarchy for storing in STORAGE.
#*sqlmount change node NAME [new NAME] [path STORAGE]
#	Change this directory hierarchy.
#	You need to copy files from the old to the new storage
#	before running this command!
#*sqlmount clone node NAME new NAME path STORAGE
#	Create a copy of an existing directory hierarchy.
#	You'll also need to specify where to copy files from; see below.
#*sqlmount del node NAME
#	Delete this node. Warning: Files may become inaccessible!
#
#*sqlmount list copy
#	List all copying commands.
#*sqlmount list copy A B
#	List details of the copy command which copies stuff from node A to B.
#*sqlmount add copy A B prio N mode HOW via CMD [ondemand|background]
#*sqlmount change copy A B [prio N] [mode HOW [via CMD]] [ondemand|background]
#	Add or change a command to copy stuff from A to B.
#	If 'ondemand' is specified, this is a caching method.
#	Otherwise, copying of all files will run in the background.
#*sqlmount del copy A B
#	Delete this method to copy files.
#
#* These commands are not implemented yet.
#"""
	opt=options("mode")
	db = Db(dbtye=opt.dbtype,host=opt.host,port=opt.port,database=opt.database,username=opt.username,password=opt.password)

	if opt.mode == "info":
		node_id,root_id = db.DoFn("select id,root from node where name=${name}", name=opt.node)
		report(node_info(db,node_id))
		report(root_info(db,root_id))

		#inum, = db.DoFn("select inode from root where id=${id}", id=root_id)
		#report(inode_info(db,inum))
	elif opt.mode == "list":
		if opt.mode2 == "node":
			if opt.name: # single node
				try:
					id,=db.DoFn("select id from node where name=${name}",name=opt.name)
				except NoData:
					raise # TODO reasonable error message
				else:
					report(node_info(db,id))
			else: # list
				if opt.root:
					try:
						root, = db.DoFn("select id from root where name=${root}", root=opt.root)
					except NoData:
						print("No node named '%s' exists" % (opt.root,),file=sys.stderr)
						sys.exit(1)
					try:
						for name, in db.DoSelect("select node.name from node,root where root.name=${root} and node.root=root.id order by name",root=opt.root):
							print(name)
					except NoData:
						print("This root does not have any nodes.",file=sys.stderr)
						
				else:
					for nodename,rootname in db.DoSelect("select node.name,root.name from node,root where node.root=root.id order by root.name,node.name"):
						print(nodename,rootname)
		elif opt.mode2 == "root":
			if opt.name:
				root_id,=db.DoFn("select id from root where name=${name}",name=opt.name)
				report(root_info(db,root_id))
			else:
				for name, in db.DoSelect("select name from root order by name"):
					print(name)
		elif opt.mode2 == "inode":
			report(inode_info(db,opt.inum))
		elif opt.mode2 == "event":
			report(event_info(db,opt.event_id))
		else:
			raise NotImplementedError("I don't know how to do that.")

	elif opt.mode == "add":
		if opt.mode2 == "root":
			inode = db.Do("insert into inode (root) values(1)")
			root = db.Do("insert into root(name,inode) values(${name},${inode})", name=opt.name,inode=inode)
			db.Do("update inode set root=${root} where id=${inode}", inode=inode, root=root)
			db.commit()
		elif opt.mode2 == "node":
			try:
				r, = db.DoFn("select id from root where name=${root}",root=opt.root)
			except NoData:
				print("No root named '%s' exists"%(opt.root,),file=sys.stderr)
				sys.exit(1)
			try:
				db.DoFn("select id from node where name=${node}", node=opt.name)
			except NoData:
				pass
			else:
				print("A node named '%s' already exists",file=sys.stderr)
				sys.exit(1)
			n = db.Do("insert into node(name,root,files) values(${node},${root},${files})", node=opt.name,root=r, files=opt.files)
			db.commit()
		else:
			raise NotImplementedError("I don't know how to do that.")

	elif opt.mode == "del":
		if opt.mode2 == "root":
			root,inode = db.DoFn("select id,inode from root where name=${root}", root=opt.name)
			c, = db.DoFn("select count(*) from node where root=${root}", root=root)
			if c:
				print("This root still has nodes and thus cannot be deleted.", file=sys.stderr)
				sys.exit(1)
			c, = db.DoFn("select count(*) from inode where root=${root}", root=root)
			if c > 1:
				print("This root still has files and thus cannot be deleted.", file=sys.stderr)
				sys.exit(1)
			if root == 1:
				print("This is the system root and thus cannot be deleted.", file=sys.stderr)
				print("You may, however, rename it.", file=sys.stderr)
				sys.exit(1)

			# This works around a MySQL bug where consistency is checked
			# immediately, not after a COMMIT as the SQL standard says
			# â€¦ which is also the main reason we need a system root in the
			# first place.
			db.Do("update inode set root=1 where id=${inode}",inode=inode)

			db.Do("delete from root where id=${root}",root=root)
			db.Do("delete from inode where id=${inode}",inode=inode)
		elif opt.mode2 == "node":
			node,root,rname = db.DoFn("select node.id,node.root,root.name from node,root where node.name=${node} and root.id=node.root", node=opt.name)
			db.Do("delete from node where id=${node}", node=node)
			c, = db.DoFn("select count(*) from node where root=${root}", root=root)
			if not c:
				print("Warning: root %d '%s' does not have any more nodes!" % (root,rname))
		else:
			raise NotImplementedError("I don't know how to do that.")
	elif opt.mode == "update":
		done = 0
		if opt.mode2 == "root":
			root, = db.DoFn("select id from root where name=${root}", root=opt.name)
			if opt.newname:
				db.Do("update root set name=${name} where id=${root}", root=root, name=opt.newname)
				done += 1
		elif opt.mode2 == "node":
			node, = db.DoFn("select id from node where name=${node}", node=opt.name)
			if opt.newname:
				db.Do("update node set name=${name} where id=${node}", node=node, name=opt.newname)
				done += 1
			if opt.files:
				db.Do("update node set files=${files} where id=${node}", node=node, files=opt.files)
				done += 1
		else:
			raise NotImplementedError("I don't know how to do that.")
		if not done:
			print("Nothing to do.")
	else:
		raise NotImplementedError("I don't yet know how to do that.")
	db.commit()

if __name__ == '__main__':
	main()
