-- MySQL dump 10.10
--
-- Host: localhost    Database: mysqlfs
-- ------------------------------------------------------
-- Server version	5.0.22-Debian_0ubuntu6.06.2

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

-- 
-- Some metadata
DROP TABLE IF EXISTS `info`;
CREATE TABLE `info` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  `value` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) DEFAULT CHARSET=utf8;
insert into info(name,value) values('version','0.2');

--
-- An inode is the primary identifier for a file or directory.
-- Note that there is no refcount.
-- CONSTRAINT: only delete the inode when copies==0
DROP TABLE IF EXISTS `inode`;
CREATE TABLE `inode` (
  `id` bigint(20) unsigned NOT NULL auto_increment,
  `mode` int(11) NOT NULL default '0',
  `uid` int(10) unsigned NOT NULL default '0',
  `gid` int(10) unsigned NOT NULL default '0',
  `atime` bigint(15) NOT NULL default '0',
  `mtime` bigint(15) NOT NULL default '0',
  `ctime` bigint(15) NOT NULL default '0',
  `atime_ns` int(10) unsigned NOT NULL default '0',
  `mtime_ns` int(10) unsigned NOT NULL default '0',
  `ctime_ns` int(10) unsigned NOT NULL default '0',
  `size` bigint(20) NOT NULL default '0', -- mirrors file size
  `rdev` int(10) NOT NULL default '0',
  `event` bigint(20) unsigned NULL, -- ID of file's latest event record
  `copies` smallint(5) unsigned not NULL default 0, -- number of physical copies
  `seq` bigint(20) unsigned not null default '1', -- update sequence number
  PRIMARY KEY (`id`),
  UNIQUE KEY `event` (`event`)
) DEFAULT CHARSET=binary;
insert into `inode` (`id`,`mode`) values (1,0); -- S_IFDIR, set when first mounting

--
-- Inodes can have extended attributes.
-- This table collects attribute names (they can be quite long and redundant).
DROP TABLE IF EXISTS `xattr_name`;
CREATE TABLE `xattr_name` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) DEFAULT CHARSET=utf8;
insert into info(name,value) values('attrnamelen','255');

-- 
-- The actaul extended attributes are here.
-- Note that the value needs to be binary.
DROP TABLE IF EXISTS `xattr`;
CREATE TABLE `xattr` (
  `id` bigint(20) unsigned NOT NULL auto_increment,
  `inode` bigint(20) unsigned NOT NULL,
  `name` int(10) unsigned NOT NULL,
  `seq` int(10) unsigned NOT NULL,
  `value` varbinary(1024) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `inode` (`inode`,`name`),
  KEY `name` (`name`),
  constraint `fk_xattr_name` foreign key(`name`) references `xattr_name`(`id`) on delete restrict,
  constraint `fk_xattr_inode` foreign key(`inode`) references `inode`(`id`) on delete cascade
) DEFAULT CHARSET=utf8;
insert into info(name,value) values('attrlen','1024');

--
-- This represents basic directory entries.
-- Root directories do not have one of their own.
DROP TABLE IF EXISTS `tree`;
CREATE TABLE `tree` (
  `inode` bigint(20) unsigned NOT NULL,
  `parent` bigint(20) unsigned not NULL,
  `name` varchar(255) NOT NULL,
  KEY `inode` (`inode`),
  UNIQUE KEY `name` (`parent`,`name`),
  constraint `fk_tree_inode` foreign key(`inode`) references `inode`(`id`) on delete cascade,
  constraint `fk_tree_parent` foreign key(`parent`) references `inode`(`id`) on delete restrict
) DEFAULT CHARSET=utf8;
insert into info(name,value) values('namelen','255');

-- 
-- You can have multiple root nodes in the system.
-- This names them.
-- CONSTRAINT: (COUNT(*) from tree where tree.inode=root.inode) == 0
--             the converse, i.e. every inode that's not a root has a tree entry,
--             does not hold (because of deletions)
CREATE TABLE `root` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `inode` bigint(20) unsigned NOT NULL,
  `name` varchar(255) NOT NULL,
  `uptodate` bigint(20) unsigned NOT NULL DEFAULT '0',
-- statistics
  `nfiles` bigint(20) unsigned not null default '1',
  `ndirs` bigint(20) unsigned not null default '1',
  `nblocks` bigint(20) unsigned not null default '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `fk_root_inode` (`inode`),
  CONSTRAINT `fk_root_inode` FOREIGN KEY (`inode`) REFERENCES `inode` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
insert into `root`(`id`,`inode`,`name`) values(1,1,'master');
insert into info(name,value) values('rootnamelen','255');

-- 
-- Multiple instances can have disparate directory views.
-- Separate nodes on the same root share identical content, eventually;
-- data will have to be copied
DROP TABLE IF EXISTS `node`;
CREATE TABLE `node` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `root` int(10) unsigned NOT NULL, -- my root
  `name` varchar(255) NOT NULL,
  `files` varchar(1024) NOT NULL, -- local file system path
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  constraint `fk_node_root` foreign key(`root`) references `root`(`id`) on delete cascade
) DEFAULT CHARSET=utf8;
insert into `node`(`id`,`root`,`name`,`files`) values(1,1,'default','/tmp/sqlmount');
insert into info(name,value) values('nodenamelen','255');
insert into info(name,value) values('nodepathlen','1024');

-- 
-- Remember file updates (and deletes). We need this to copy files.
-- 
DROP TABLE IF EXISTS `event`;
CREATE TABLE `event` (
  `id` bigint(20) unsigned NOT NULL auto_increment,
  `inode` bigint(20) unsigned NOT NULL,
  `node` int(10) unsigned NOT NULL,
  `typ` char(1) NOT NULL, -- 'n'ew 'c'hange 'f'inish_write 'd'elete 'i'nit_node
  `range` varbinary(1023) NULL, -- for change records: what was witten?
  PRIMARY KEY (`id`),
  KEY `fk_event_node` (`node`),
  KEY `fk_event_inode` (`inode`),
  constraint `fk_event_inode` foreign key(`inode`) references `inode`(`id`) on delete restrict,
  constraint `fk_event_node` foreign key(`node`) references `node`(`id`) on delete restrict
) DEFAULT CHARSET=binary;
insert into info(name,value) values('rangelen','1023');
alter table `inode` add constraint `fk_inode_event` foreign key(`event`) references `event`(`id`) on delete restrict;

insert into `event` (`id`,`inode`,`node`,`typ`) values (1,1,1,'i');

-- 
-- Collect which event from which node has been processed completely
-- on any given node. This table is necessary because on master/master
-- database setups, each node gets their own ID sequences.
-- CONSTRAINT: src != dest
-- no record == all existing change records are unprocessed;
-- the "on delete cascade" clauses cause this table to be self-cleaning-up
DROP TABLE IF EXISTS `uptodate`;
CREATE TABLE `uptodate` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `src` int(10) unsigned NOT NULL, -- the node generating the event
  `dest` int(10) unsigned NOT NULL, -- the node processing the event
  `event` bigint(20) unsigned NOT NULL, -- last that's been processed here
  PRIMARY KEY (`id`),
  KEY `fk_uptodate_event` (`event`),
  KEY `fk_uptodate_dest` (`dest`),
  KEY `fk_uptodate_src` (`src`),
  constraint `fk_uptodate_src` foreign key(`src`) references `node`(`id`) on delete cascade,
  constraint `fk_uptodate_dest` foreign key(`dest`) references `node`(`id`) on delete cascade,
  constraint `fk_uptodate_event` foreign key(`event`) references `event`(`id`) on delete cascade
) DEFAULT CHARSET=utf8;

-- 
-- How to do updates
-- 
DROP TABLE IF EXISTS `updater`;
CREATE TABLE `updater` (
  `id` int(10) unsigned NOT NULL,
  `src` int(10) unsigned NOT NULL, -- the node I'm copying from
  `dest` int(10) unsigned NOT NULL, -- my ID
  `distance` tinyint(2) unsigned NOT NULL, -- how expensive is copying?
  `method` varchar(10) not null, -- some Python class or other
  `source` varchar(1024) not null, -- some class-specific parameters
  `autocopy` bool not null default true, -- if false, only copy on demand
  PRIMARY KEY (`id`),
  KEY `fk_updater_dest` (`dest`),
  KEY `fk_updater_src` (`src`),
  constraint `fk_updater_src` foreign key(`src`) references `node`(`id`) on delete cascade,
  constraint `fk_updater_dest` foreign key(`dest`) references `node`(`id`) on delete cascade
  ) DEFAULT CHARSET=utf8;

-- 
-- record completed updates, for event clean-up
-- 
DROP TABLE IF EXISTS `done`;
CREATE TABLE `done` (
  `id` bigint(20) unsigned NOT NULL,
  `src` int(10) unsigned NOT NULL, -- the node I'm copying from
  `dest` int(10) unsigned NOT NULL, -- my ID
  `event` bigint(20) unsigned NOT NULL, -- if NULL, no auto-copy will happen
  PRIMARY KEY (`id`),
  KEY `fk_done_event` (`event`),
  KEY `fk_done_dest` (`dest`),
  KEY `fk_done_src` (`src`),
  constraint `fk_done_src` foreign key(`src`) references `node`(`id`) on delete cascade,
  constraint `fk_done_dest` foreign key(`dest`) references `node`(`id`) on delete cascade,
  constraint `fk_done_event` foreign key(`event`) references `event`(`id`) on delete restrict
) DEFAULT CHARSET=utf8;


/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

